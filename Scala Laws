ğŸ”¹ 1. Law of Field Access
â— You cannot access a field from a list â€” only from the individual objects inside the list.

customers.map(_.name)        âœ… Access name from each customer
customers.name               âŒ List[Customer] has no `.name`

ğŸ“Œ Rule: You must .map or loop to get inside each element.
--------------------------------------------------------------------------------------------------------------------------
ğŸ”¹ 2. Law of Lambda Return Values
â— A lambda like x => ... must return one single value, not multiple expressions.

x => (x.name, x.age)         âœ… One tuple
x => x.name, x.age           âŒ Two expressions â€” not allowed

ğŸ“Œ Rule: Always return a single value from a function body. Use tuples or case classes or () to group multiple values.
--------------------------------------------------------------------------------------------------------------------------
ğŸ”¹ 3. Law of .map vs .flatMap
â— Use .map if your lambda returns one item
â— Use .flatMap if your lambda returns a list (or any wrapper like Option, Future, etc.)

List("A", "B").map(x => List(x, x + "!"))
// â†’ List(List("A", "A!"), List("B", "B!"))

List("A", "B").flatMap(x => List(x, x + "!"))
// â†’ List("A", "A!", "B", "B!")

ğŸ“Œ Rule: Use .flatMap when you return nested structures and want them flattened automatically.
--------------------------------------------------------------------------------------------------------------------------
ğŸ”¹ 4. Law of Option Safety
âŒ Never blindly use .get on an Option
âœ… Use .map, .flatMap, .getOrElse, or pattern match

opt.map(_ + 1)               âœ… Safe
opt.get                      âŒ Unsafe â€” throws exception if None
opt.getOrElse(0)             âœ… Safe fallback

ğŸ“Œ Rule: If it can be None, assume it will be. Always unwrap safely.
--------------------------------------------------------------------------------------------------------------------------
ğŸ”¹ 5. Law of Purity & Immutability
Functional Scala avoids side effects.
Every function should produce the same output for the same input.

No mutation
No printing to console
No hidden state

ğŸ“Œ Rule: Transform inputs â†’ outputs, without modifying the inputs.
--------------------------------------------------------------------------------------------------------------------------
ğŸ”¹ 6. Law of Shape Consistency
The type of each transformation matters.
You must always know: What shape am I producing at this step?

.map returns A â†’ B             // same number of elements
.flatMap returns A â†’ List[B]  // flattens nested output
.groupBy returns Map[K, List[V]]

ğŸ“Œ Rule: Understand what your list turns into after each transformation.
--------------------------------------------------------------------------------------------------------------------------
ğŸ”¹ 7. Law of Expression Chains
Functional style builds up transformations in steps, not with temporary state.

  .filter(...)
  .map(...)
  .groupBy(...)
  .mapValues(...)
  
ğŸ“Œ Rule: Chain functions when theyâ€™re pure and readable. Break into vals when clarity suffers.
--------------------------------------------------------------------------------------------------------------------------

ğŸ”¹ 8. Law of Type Safety
If it compiles, it works â€” as long as the types line up.

List[Option[Double]].flatMap(identity)  âœ…
List[Transaction].map(_.amount.get)     âŒ unsafe unless guaranteed

ğŸ“Œ Rule: Always know what type you're passing and receiving â€” Scala's type system protects you if you respect it.
--------------------------------------------------------------------------------------------------------------------------

